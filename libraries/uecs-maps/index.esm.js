class t{static for(e){const n=e.toString();let s=t.cache[n];return null==s&&(s=Object.defineProperty(class{},"name",{value:"T$"+n}),t.cache[n]=s),s}}t.cache={};const e=-1;class n{constructor(){this.entitySequence=0,this.entities=new Set,this.components={},this.views={}}create(...t){const e=this.entitySequence++;this.entities.add(e);for(let n=0,s=t.length;n<s;++n)this.emplace(e,t[n]);return e}insert(t,...e){t>=this.entitySequence&&(this.entitySequence=t+1),this.entities.add(t);for(let n=0,s=e.length;n<s;++n)this.emplace(t,e[n]);return t}exists(t){return this.entities.has(t)}destroy(t){this.entities.delete(t);for(const e in this.components){const n=this.components[e],s=n.get(t);void 0!==s&&void 0!==s.free&&s.free(),n.delete(t)}}get(t,e){const n=e.name,s=this.components[n];if(void 0!==s)return s.get(t)}has(t,e){const n=e.name,s=this.components[n];return void 0!==s&&s.has(t)}emplace(t,e){var n;const s=null!==(n=e.name)&&void 0!==n?n:e.constructor.name;if(!this.entities.has(t))throw new Error(`Cannot set component "${s}" for dead entity ID ${t}`);let i=this.components[s];void 0===i&&(i=new Map,this.components[s]=i),i.set(t,e)}remove(t,e){const n=e.name,s=this.components[n];if(void 0===s)return;const i=s.get(t);return s.delete(t),i}size(){return this.entities.size}view(...t){let e="";for(let n=0;n<t.length;++n)e+=t[n].name;if(!(e in this.views)){for(let e=0;e<t.length;++e)void 0===this.components[t[e].name]&&(this.components[t[e].name]=new Map);this.views[e]=new s(this,t)}return this.views[e]}clear(){for(const t of this.entities.values())this.destroy(t)}all(){return this.entities.values()}}class s{constructor(t,e){this.view=function(t,e){const n=e.length;let s="";const o=[];for(let t=0;t<n;++t){const n=e[t].name,r=`${i.storage}${n}`;s+=`const ${r} = ${i.world}.components["${n}"];\n`,o.push(r)}let r="";r+="let min = Infinity;\n",r+="let storage = undefined;\n";for(let t=0;t<n;++t)r+=`if (${o[t]}.size < min) {\n    storage = ${o[t]};\n    min = ${o[t]}.size;\n}\n`;r+="if (storage === undefined) return;\n",r+=`const ${i.entities} = storage.keys();\n`;let c="";const l=[];for(let t=0;t<n;++t){const n=`${e[t].name}${t}`;c+=`const ${n} = ${o[t]}.get(${i.entity});\n`,l.push(n)}let a="if (";for(let t=0;t<n;++t)a+=`${l[t]} === undefined`,t!==n-1&&(a+=" || ");a+=") continue;\n";const h=s+`return function(${i.callback}) {\n`+r+`for (const ${i.entity} of ${i.entities}) {\n`+c+a+`if (${i.callback}(${i.entity},${function(t,e){let n="";const s=t.length-1;for(let i=0;i<s;++i)n+=t[i]+e;return n+=t[s],n}(l,",")}) === false) return;\n}\n}`;return new Function(i.world,h)(t)}(t,e)}each(t){this.view(t)}}const i={world:"_$WORLD",entity:"_$ENTITY",entities:"_$ENTITIES",callback:"_$CALLBACK",storage:"_$STORAGE"};export{e as Null,t as Tag,n as World};
