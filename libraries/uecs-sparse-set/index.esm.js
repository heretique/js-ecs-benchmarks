function t(t,e){return t.left<e.left&&t.right<e.right?-1:t.left>e.left&&t.right>e.right?1:0}class e{constructor(){this.free=[],this.free.push({left:1,right:Number.MAX_SAFE_INTEGER})}reserve(){const t=this.free[0];if(t.left==Number.MAX_SAFE_INTEGER)return 0;const e=t.left;if(t.left+1<t.right)this.free[0]={left:t.left+1,right:t.right};else{if(t.left+1==Number.MAX_SAFE_INTEGER)return 0;this.free.shift()}return e}release(e){if(0==e||e==Number.MAX_SAFE_INTEGER)return;const s=this.free.findIndex((t=>t.left<=e&&t.right>e));if(-1==s)this.free.push({left:e,right:e+1});else{const t=this.free[s],n={left:t.left,right:e},i={left:e+1,right:t.right};this.free.splice(s,1,n,i)}this.free.sort(t)}}class s{constructor(t){this.size=0,this.maxCapacity=55e4,this.capacity=t,this.dense=new Int32Array(t),this.sparse=new Int32Array(t)}add(t){if(t>=this.maxCapacity)throw new Error(`Value ${t} is greater than or equal to the maximum capacity of the data structure ${this.maxCapacity}`);if(t>=this.capacity){const e=Math.max(2*this.capacity,t+1),s=new Int32Array(e),n=new Int32Array(e);s.set(this.dense),n.set(this.sparse),this.dense=s,this.sparse=n,this.capacity=e}const e=this.size;return this.dense[e]=t,this.sparse[t]=e,this.size++,e}remove(t){if(0===this.size)return;const e=this.size-1,s=this.sparse[t];this.dense[s]=this.dense[e],this.sparse[this.dense[e]]=s,this.size--}has(t){return this.sparse[t]<this.size&&this.dense[this.sparse[t]]==t}clear(){this.size=0}getSize(){return this.size}getCapacity(){return this.capacity}get(t){return this.sparse[t]}getValues(){return this.dense}[Symbol.iterator](){let t=0;return{next:()=>t<this.size?{done:!1,value:this.dense[t++]}:{done:!0,value:null}}}forEach(t){for(let e=0;e<this.size;e++)t(this.dense[e])}map(t){const e=[];for(let s=0;s<this.size;s++)e.push(t(this.dense[s]));return e}filter(t){const e=[];for(let s=0;s<this.size;s++)t(this.dense[s])&&e.push(this.dense[s]);return e}}const n=-1;class i{constructor(){this.ids=new e,this.entities=new s(400096),this.componentsStorage={},this.views={}}create(...t){const e=this.ids.reserve();this.entities.add(e);for(let s=0,n=t.length;s<n;++s)this.emplace(e,t[s]);return e}exists(t){return this.entities.has(t)}destroy(t){if(this.entities.has(t)){this.entities.remove(t),this.ids.release(t);for(const e in this.componentsStorage){const s=this.componentsStorage[e],n=s.sparseSet;if(n.has(t)){const e=n.get(t),i=s.components[e];void 0!==i&&void 0!==i.free&&i.free(),n.remove(t)}}}}get(t,e){const s=e.name,n=this.componentsStorage[s];if(void 0===n)return;const i=n.sparseSet;if(!i.has(t))return;const r=i.get(t);return n.components[r]}has(t,e){const s=e.name,n=this.componentsStorage[s];return void 0!==n&&n.sparseSet.has(t)}emplace(t,e){var n;const i=null!==(n=e.name)&&void 0!==n?n:e.constructor.name;if(!this.entities.has(t))throw new Error(`Cannot set component "${i}" for dead entity ID ${t}`);let r=this.componentsStorage[i];void 0===r&&(r={components:[],sparseSet:new s(400096)}),this.componentsStorage[i]=r;const o=r.sparseSet.add(t);r.components[o]=e}remove(t,e){const s=e.name,n=this.componentsStorage[s];if(void 0===n)return;const i=n.sparseSet;if(!i.has(t))return;const r=i.get(t),o=n.components[r],a=i.getSize()-1;return n.components[r]=n.components[a],n.components.pop(),i.remove(t),o}size(){return this.entities.getSize()}view(...t){let e="";for(let s=0;s<t.length;++s)e+=t[s].name;if(!(e in this.views)){for(let e=0;e<t.length;++e)void 0===this.componentsStorage[t[e].name]&&(this.componentsStorage[t[e].name]={components:[],sparseSet:new s(400096)});this.views[e]=new r(this,t)}return this.views[e]}clear(){for(;this.entities.getSize()>0;)this.destroy(this.entities.getValues()[0])}all(){return this.entities}}class r{constructor(t,e){this.view=function(t,e){const s=e.length;let n="";const i=[];for(let t=0;t<s;++t){const s=e[t].name,r=`${o.storage}${s}`;n+=`const ${r} = ${o.world}.componentsStorage["${s}"];\n`,i.push(r)}let r="";r+="let min = Infinity;\n",r+="let storage = undefined;\n";for(let t=0;t<s;++t)r+=`if (${i[t]}.components.length < min) {\n  storage = ${i[t]};\n  min = ${i[t]}.components.length;\n}\n`;r+="if (storage === undefined) return;\n",r+=`const ${o.entities} = storage.sparseSet.getValues();\n`;let a="";a+="if (";for(let t=0;t<s;++t)a+=`!${i[t]}.sparseSet.has(${o.entity})`,t!==s-1&&(a+=" || ");a+=") continue;\n";let h="";h+="let index = 0;\n";const c=[];for(let t=0;t<s;++t){const s=`${e[t].name}${t}`;h+=`index = ${i[t]}.sparseSet.get(${o.entity});\n`,h+=`const ${s} = ${i[t]}.components[index];\n`,c.push(s)}const l=n+`return function(${o.callback}) {\n`+r+`for (const ${o.entity} of ${o.entities}) {\n`+a+h+`if (${o.callback}(${o.entity},${function(t,e){let s="";const n=t.length-1;for(let i=0;i<n;++i)s+=t[i]+e;return s+=t[n],s}(c,",")}) === false) return;\n}\n}`;return new Function(o.world,l)(t)}(t,e)}each(t){this.view(t)}}const o={world:"_$WORLD",entity:"_$ENTITY",entities:"_$ENTITIES",callback:"_$CALLBACK",storage:"_$STORAGE"};class a{static for(t){const e=t.toString();let s=a.cache[e];return null==s&&(s=Object.defineProperty(class{},"name",{value:"T$"+e}),a.cache[e]=s),s}}a.cache={};export{n as Null,a as Tag,i as World};
